#!/usr/bin/env python
__author__ = 'David Malcolm <dmalcolm@redhat.com>, Zack Cerza <zcerza@redhat.com>'

# Event recorder.
# FIXME: under construction

# Begin GUI code
import gobject
import gnome
import gtk.glade
class RecorderGUI(gnome.Program):
    def __init__(self):
        gnome.Program.__init__(self)
        appName = 'Recorder'
        appAuthors = ['Zack Cerza <zcerza@redhat.com>']
        program = gnome.program_init(appName, '0.1')

        try:
            x = gtk.glade.XML('recorder.glade')
        except RuntimeError:
            x = gtk.glade.XML('/usr/share/dogtail/glade/recorder.glade')

        self.window = x.get_widget('window')

        try:
            self.window.set_icon_from_file('../icons/dogtail-head.svg')
        except:
            self.window.set_icon_from_file('/usr/share/icons/hicolor/scalable/apps/dogtail-head.svg')

        self.recordButton = x.get_widget('recordButton')
        self.stopButton = x.get_widget('stopButton')
        self.stopButton.set_sensitive(False)
        self.saveButton = x.get_widget('saveButton')
        self.saveButton.set_sensitive(False)
        self.quitButton = x.get_widget('quitButton')
        self.scriptTextView = x.get_widget('scriptTextView')
        self.scriptTextView.set_editable(False)

        self.connectSignals()

        self.window.show_all()
        gtk.main()

    def connectSignals(self):
        self.recordButton.connect('clicked', self.startRecording, self.scriptTextView)
        self.stopButton.connect('clicked', self.stopRecording, self.scriptTextView)
        self.saveButton.connect('clicked', self.saveScript)
        self.quitButton.connect('clicked', self.quit)

    def startRecording(self, unused = None, scriptTextView = None):
        self.recordButton.set_sensitive(False)
        self.saveButton.set_sensitive(False)
        self.scriptTextView.set_editable(False)
        self.stopButton.set_sensitive(True)
        recorder.startRecording(unused, scriptTextView)

    def stopRecording(self, unused = None, scriptTextView = None):
        self.recordButton.set_sensitive(True)
        self.saveButton.set_sensitive(True)
        self.scriptTextView.set_editable(True)
        self.stopButton.set_sensitive(False)
        recorder.stopRecording(unused, scriptTextView)

    def saveScript(self, button):
        """
        Brings up a file chooser dialog asking where to save the script.
        """
        self.saveFileChooser = gtk.FileChooserDialog("Save Script...", None, \
            gtk.FILE_CHOOSER_ACTION_SAVE, (gtk.STOCK_CANCEL, \
            gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK))
        self.saveFileChooser.set_default_response(gtk.RESPONSE_OK)

        # Why this isn't default, I do not understand.
        self.saveFileChooser.set_do_overwrite_confirmation(True)

        filter = gtk.FileFilter()
        filter.set_name('Python files')
        filter.add_pattern('*.py')
        self.saveFileChooser.add_filter(filter)
        filter = gtk.FileFilter()
        filter.set_name('All Files')
        filter.add_pattern('*')
        self.saveFileChooser.add_filter(filter)

        response = self.saveFileChooser.run()
        if response == gtk.RESPONSE_OK:
            fileName = self.saveFileChooser.get_filename()
            # Append a .py to the file name if necessary
            if fileName[-3:] != '.py':
                fileName += '.py'
            file = open(fileName, 'w')
            buffer = self.scriptTextView.get_buffer()
            startIter = buffer.get_start_iter()
            endIter = buffer.get_end_iter()
            scriptText = buffer.get_text(startIter, endIter)
            file.write(scriptText)
            file.close()
        self.saveFileChooser.destroy()

    def quit(*args):
        gtk.main_quit()
    quit = staticmethod(quit)

# End GUI code

import atspi
import dogtail.tree

def logEvent(event):
    source = event.source
    if isinstance(source, atspi.Accessible):
        sourceStr = " source:%s"%(str(dogtail.tree.Node(source)))
    else:
        sourceStr = ""
    print "Got event: %s%s"%(event.type, sourceStr)

class ScriptWriter:
    """
    Abstract Writer subclass which writes out Python scripts
    """
    def __init__(self, scriptTextView = None):
        self.scriptBuffer = ""
        self.scriptTextView = scriptTextView
        self.debug = False

    def recordLine(self, string):
        print string
        if self.scriptTextView:
            buffer = self.scriptTextView.get_buffer()
            iter = buffer.get_end_iter()
            buffer.insert(iter, string + '\n')
        else:
            self.scriptBuffer += '\n' + string

    def recordClick(self, node):
        raise NotImplementedError

    def recordKey(self, node):
        raise NotImplementedError

class OOScriptWriter(ScriptWriter):
    """
    Concrete Writer subclass which writes out Python scripts in an object-oriented
    style
    """
    def __init__(self, scriptTextView = None):
        ScriptWriter.__init__(self, scriptTextView)

        self.debugVariables = False

        self.recordLine("#!/usr/bin/python")
        self.recordLine("from dogtail.tree import *\n")

        # maintain a dict from variable names to search paths
        self.variables = {}

    def generateVariableName(self, predicate):
        # Ensure uniqueness
        result = predicate.makeScriptVariableName()
        if result in self.variables:
            # This variable name is already in use; need to append a number:
            index = 1
            while result+str(index) in self.variables:
                index+=1
            return result+str(index)
        else:
            return result

    def printVariables(self):
        # debug hook
        print "variables:"
        for (varName, varAbsPath) in self.variables.iteritems():
            print "varName:%s -> absPath:%s"%(varName, varAbsPath)

    def generateAbsSearchPathMethodCall(self, absSearchPath):
        """
        Generates a method call that identifies the absolute search path,
        optimizing away prefixes where possible with variable names.
        """
        # We optimize away the longest common absolute path prefix, i.e. the
        # shortest relative path suffix:
        if self.debug:
            print "*******************"
            print "generateAbsSearchPathMethodCall for %s"%absSearchPath
            self.printVariables()

        shortestRelativePath = None
        for (varName, varAbsPath) in self.variables.iteritems():
            relPath = varAbsPath.getRelativePath(absSearchPath)
            if relPath:
                if shortestRelativePath:
                    if relPath.length() < shortestRelativePath[2].length():
                        shortestRelativePath = (varName, varAbsPath, relPath)
                else:
                    shortestRelativePath = (varName, varAbsPath, relPath)

        if self.debug:
            if shortestRelativePath:
                (varName, varAbsPath, relPath) = shortestRelativePath
                print "shortestRelativePath: (%s, %s, %s)"%(varName, varAbsPath, relPath)
            else:
                print "shortestRelativePath: None"
            print "*******************"

        if shortestRelativePath:
            (varName, varAbsPath, relPath) = shortestRelativePath
            return varName+relPath.makeScriptMethodCall()
        else:
            # Have to specify it as an absolute path:
            return "root"+absSearchPath.makeScriptMethodCall()

    def recordKey(self, node, key):
        """
        Record a keystroke

        NOTE: This function is under construction. It doesn't work.
        """
        if node == None: return
        searchPath = node.getAbsoluteSearchPath()
        result = self.generateAbsSearchPathMethodCall(searchPath)
        result +=".rawType('%s')" % key

    def recordClick(self, node):
        """
        Record a mouse click
        """
        if node == None: return
        searchPath = node.getAbsoluteSearchPath()

        if self.debug:
            print "----------------------------------"
            print "click on %s"%searchPath
            print "Full script would be: root%s"%searchPath.makeScriptMethodCall()

        # Generate variables for nodes likely to be referred to often (application, window)
        # FIXME: make this smarter?
        for i in [1,2,3]:
            if i<searchPath.length():

                prefixPath = searchPath.getPrefix(i)

                if self.debugVariables:
                    print "Considering: %s"%prefixPath

                if not prefixPath in self.variables.values():
                    if self.debugVariables:
                        print "It is not yet a variable"
                        self.printVariables()

                    predicate = prefixPath.getPredicate(i-1)
                    varName = predicate.makeScriptVariableName()
                    self.recordLine(varName+" = "+self.generateAbsSearchPathMethodCall(prefixPath))
                    self.variables[varName]=prefixPath
                else:
                    if self.debugVariables:
                        print "It is already a variable"

        result = self.generateAbsSearchPathMethodCall(searchPath)
        result +=".click()"

        if self.debug:
            print "----------------------------------"

        self.recordLine(result)

class ProceduralScriptWriter(ScriptWriter):
    """
    Concrete Writer subclass which writes out Python scripts in a procedural
    style
    """
    
    currentWidget = None
    currentDialog = None
    currentApplication = None

    def __init__(self, scriptTextView = None):
        ScriptWriter.__init__(self, scriptTextView)

        self.recordLine("#!/usr/bin/python")
        self.recordLine("from dogtail.procedural import *\n")
    
    def findAncestor(self, node, name = None, roleName = None, description = None):
        while node.parent:
            nameMatch = False
            roleNameMatch = False
            descMatch = False
            if name != None: nameMatch = node.parent.name == name
            else: nameMatch = True
            if roleName != None: roleNameMatch = node.parent.roleName == roleName
            else: roleNameMatch = True
            if description != None: 
                descMatch = node.parent.description == description
            else: descMatch = True
            match = nameMatch and roleNameMatch and descMatch
            if match: return node.parent
            node = node.parent
        return None

    def recordClick(self, node):
        assert node
        
        application = self.findAncestor(node, roleName = 'application')
        if application:
            needApp = True
            if self.currentApplication:
                if application == self.currentApplication: needApp = False
            if needApp:
                self.recordLine("focus.application('%s')" % application.name)
                self.currentApplication = application

        dialog = self.findAncestor(node, roleName = 'dialog')
        if dialog:
            needDialog = True
            if dialog == self.currentDialog: needDialog = False
            if needDialog:
                self.recordLine("focus.dialog('%s')" % dialog.name)
                self.currentDialog = dialog
        
        widget = node
        self.recordLine("click('%s', roleName='%s')" % (widget.name, widget.roleName))
        self.currentWidget = widget
        

    def recordKey(self, node):
        pass


class FakeNode(dogtail.tree.Node):
    """A "cached pseudo-copy" of a Node

    This class exists for cases where we know we're going to need information
    about a Node instance at a point in time where it's no longer safe to
    assume that the Accessible it wraps is still valid. It is designed to
    cache enough information to allow all of the necessary Node methods to
    execute properly and return something meaningful.

    As it is often necessary to know the Node instance's parent, it creates
    FakeNode instances of each and every one of its ancestors.
    """
    def __init__(self, node):
        assert node

        self.__node = node
        self.name = self.__node.name
        self.roleName = self.__node.roleName
        self.description = self.__node.description
        self.debugName = self.__node.debugName

        try: self.text = self.__node.text
        except AttributeError: self.text = None

        try: self.position = self.__node.position
        except AttributeError: self.position = None

        try: self.size = self.__node.size
        except AttributeError: self.size = None

        if node.parent: self.parent = FakeNode(self.__node.parent)
        else: self.parent = None

        if node.labellee: self.labellee = FakeNode(self.__node.labellee)
        else: self.labellee = None

    def __getattr__(self, name):
        raise AttributeError, name

    def __setattr__(self, name, value):
        self.__dict__[name] = value

    def __cmp__(self, otherNode):
        if not otherNode: return True

        nameMatch = False
        roleNameMatch = False
        descMatch = False
        nameMatch = otherNode.name == self.name
        roleNameMatch = otherNode.roleName == self.roleName
        descMatch = otherNode.description == self.description
        match = nameMatch and roleNameMatch and descMatch
        return not match


# Singleton EventRecorder
global recorder

class EventRecorder:
    """
    Event Recorder
    """
    def __init__(self, writerClass = OOScriptWriter):
        self.writer = None
        self.writerClass = writerClass
        self.lastFocusedNode = None
        self.lastSelectedNode = None
        self.lastPressedNode = None
        self.lastReleasedNoed = None
        self.absoluteNodePaths = True

    def __registerEvents(self):
        # Only specific events are recorded:
        listeners = []

        # Focus events:
        listeners.append(atspi.EventListener(marshalOnFocus, ["focus:"]))

        # State Changed events:
        listeners.append(atspi.EventListener(marshalOnSelect, ["object:state-changed:selected"]))

        # Mouse button-1 clicks:
        listeners.append(atspi.EventListener(marshalOnMouseButton, ["mouse:button"]))

        # Window creation:
        listeners.append(atspi.EventListener(marshalOnWindowCreate, ["window:create"]))

        return listeners

    def startRecording(self, unused = None, scriptTextView = None):
        self.writer = self.writerClass(scriptTextView)
        self.listeners = self.__registerEvents()
        atspi.event_main()

    def stopRecording(self, unused = None, scriptTextView = None):
        for listener in self.listeners:
            listener.deregister()
        atspi.event_quit()
        self.writer = None

    def onFocus(self, event):
        #logEvent(event)

        sourceNode = dogtail.tree.Node(event.source)
        sourceNode = FakeNode(sourceNode)
        self.lastFocusedNode = sourceNode

    def onSelect(self, event):
        #logEvent(event)

        sourceNode = dogtail.tree.Node(event.source)
        sourceNode = FakeNode(sourceNode)
        self.lastSelectedNode = sourceNode

    def onMouseButton(self, event):
        #logEvent(event)

        isPress = isRelease = False
        if "mouse:button:1" not in event.type:
            return
        elif event.type == "mouse:button:1p":
            isPress = True
        elif event.type == "mouse:button:1r":
            isRelease = True

        # The source node is always "main" - which sucks.
        # sourceNode = dogtail.tree.Node(event.source)

        #print "position", self.lastFocusedNode.position
        #print "size", self.lastFocusedNode.size

        x = event.detail1
        y = event.detail2
        #print "x,y: %s, %s" % (x, y)
        for node in (self.lastFocusedNode, self.lastSelectedNode):
            #print "position: %s, size: %s" % (node.position, node.size)
            try:
                if node.position:
                    if node.position[0] <= x <= (node.position[0] + node.size[0]) and \
                            node.position[1] <= y <= (node.position[1] + node.size[1]):
                        if isPress: self.lastPressedNode = node
                        elif isRelease: self.lastReleasedNode = node
                        break
            except AttributeError: pass

        assert self.lastFocusedNode:
        
        if isRelease: self.writer.recordClick(self.lastFocusedNode)

    def onWindowCreate(self, event):
        # logEvent(event)
        sourceNode = dogtail.tree.Node(event.source)
        # print "Window creation: %s"%str(sourceNode)

    def getLogStringForNode(self, node):
        if self.absoluteNodePaths:
            return node.getAbsoluteSearchPath()
        else:
            return node

# Under construction.  These ought to be methods, but am having Python assertion
# failures in refcounting when trying to hook them up using lambda expressions; grrr...
def marshalOnFocus(event):
    recorder.onFocus(event)

def marshalOnSelect(event):
    recorder.onSelect(event)

def marshalOnMouseButton(event):
    recorder.onMouseButton(event)

def marshalOnWindowCreate(event):
    recorder.onWindowCreate(event)

#recorder = EventRecorder()
recorder = EventRecorder(ProceduralScriptWriter)
recorderGUI = RecorderGUI()
#recorder.writer.debug = True
#recorder.writer.debugVariables = True


# vim: sw=4 ts=4 sts=4 et ai
