#!/usr/bin/env python
__author__ = 'David Malcolm <dmalcolm@redhat.com>, Zack Cerza <zcerza@redhat.com>'

# Event recorder.
# FIXME: under construction

# Begin GUI code
import gobject
import gnome
import gtk.glade
class RecorderGUI(gnome.Program):
    def __init__(self):
        gnome.Program.__init__(self)
        appName = 'Recorder'
        appAuthors = ['Zack Cerza <zcerza@redhat.com>']
        program = gnome.program_init(appName, '0.1')

        try:
            x = gtk.glade.XML('recorder.glade')
        except RuntimeError:
            x = gtk.glade.XML('/usr/share/dogtail/glade/recorder.glade')

        self.window = x.get_widget('window')

        try:
            self.window.set_icon_from_file('../icons/dogtail-head.svg')
        except:
            self.window.set_icon_from_file('/usr/share/icons/hicolor/scalable/apps/dogtail-head.svg')

        self.recordButton = x.get_widget('recordButton')
        self.stopButton = x.get_widget('stopButton')
        self.stopButton.set_sensitive(False)
        self.saveButton = x.get_widget('saveButton')
        self.saveButton.set_sensitive(False)
        self.quitButton = x.get_widget('quitButton')
        self.scriptTextView = x.get_widget('scriptTextView')
        self.scriptTextView.set_editable(False)
        self.writerComboBox = x.get_widget('writerComboBox')
        self.writerComboBox.set_active(0)
        self.writerComboBox.set_sensitive(True)

        self.connectSignals()

        self.window.show_all()
        gtk.main()

    def connectSignals(self):
        self.writerComboBox.connect('changed', self.setWriterClass)
        self.recordButton.connect('clicked', self.startRecording, self.scriptTextView)
        self.stopButton.connect('clicked', self.stopRecording, self.scriptTextView)
        self.saveButton.connect('clicked', self.saveScript)
        self.quitButton.connect('clicked', self.quit)

    def setWriterClass (self, comboBox):
        selected = comboBox.get_active_text()
        if selected == "Procedural":
            recorder.writerClass = ProceduralScriptWriter
        elif selected == "Object-Oriented":
            recorder.writerClass = OOScriptWriter
        else:
            print selected, "isn't a ScriptWriter, but it is selected. How?"

    def startRecording(self, unused = None, scriptTextView = None):
        self.writerComboBox.set_sensitive(False)
        self.recordButton.set_sensitive(False)
        self.saveButton.set_sensitive(False)
        self.scriptTextView.set_editable(False)
        self.stopButton.set_sensitive(True)
        recorder.startRecording(unused, scriptTextView)

    def stopRecording(self, unused = None, scriptTextView = None):
        self.writerComboBox.set_sensitive(True)
        self.recordButton.set_sensitive(True)
        self.saveButton.set_sensitive(True)
        self.scriptTextView.set_editable(True)
        self.stopButton.set_sensitive(False)
        recorder.stopRecording(unused, scriptTextView)

    def saveScript(self, button):
        """
        Brings up a file chooser dialog asking where to save the script.
        """
        self.saveFileChooser = gtk.FileChooserDialog("Save Script...", None, \
            gtk.FILE_CHOOSER_ACTION_SAVE, (gtk.STOCK_CANCEL, \
            gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK))
        self.saveFileChooser.set_default_response(gtk.RESPONSE_OK)

        # Why this isn't default, I do not understand.
        self.saveFileChooser.set_do_overwrite_confirmation(True)

        filter = gtk.FileFilter()
        filter.set_name('Python files')
        filter.add_pattern('*.py')
        self.saveFileChooser.add_filter(filter)
        filter = gtk.FileFilter()
        filter.set_name('All Files')
        filter.add_pattern('*')
        self.saveFileChooser.add_filter(filter)

        response = self.saveFileChooser.run()
        if response == gtk.RESPONSE_OK:
            fileName = self.saveFileChooser.get_filename()
            # Append a .py to the file name if necessary
            if fileName[-3:] != '.py':
                fileName += '.py'
            file = open(fileName, 'w')
            buffer = self.scriptTextView.get_buffer()
            startIter = buffer.get_start_iter()
            endIter = buffer.get_end_iter()
            scriptText = buffer.get_text(startIter, endIter)
            file.write(scriptText)
            file.close()
        self.saveFileChooser.destroy()

    def quit(*args):
        gtk.main_quit()
    quit = staticmethod(quit)

# End GUI code

import atspi
import dogtail.tree

def logEvent(event):
    source = event.source
    if isinstance(source, atspi.Accessible):
        sourceStr = " source:%s"%(str(dogtail.tree.Node(source)))
    else:
        sourceStr = ""
    print "Got event: %s%s"%(event.type, sourceStr)

class ScriptWriter:
    """
    Abstract Writer subclass which writes out Python scripts
    """
    def __init__(self, scriptTextView = None):
        self.scriptBuffer = ""
        self.scriptTextView = scriptTextView
        self.debug = False

    def recordLine(self, string):
        print string
        if self.scriptTextView:
            buffer = self.scriptTextView.get_buffer()
            iter = buffer.get_end_iter()
            if buffer.get_line_count() > 1:
                string = '\n' + string
            buffer.insert(iter, string)
            
            # Scroll to the end
            iter = buffer.get_end_iter()
            mark = buffer.create_mark('end', iter, True)
            self.scriptTextView.scroll_mark_onscreen(mark)
            buffer.delete_mark(mark)
        else:
            self.scriptBuffer += '\n' + string

    def recordClick(self, node):
        raise NotImplementedError

    def recordKey(self, node):
        raise NotImplementedError

class OOScriptWriter(ScriptWriter):
    """
    Concrete Writer subclass which writes out Python scripts in an object-oriented
    style
    """
    def __init__(self, scriptTextView = None):
        ScriptWriter.__init__(self, scriptTextView)

        self.debugVariables = False

        self.recordLine("#!/usr/bin/python\nfrom dogtail.tree import *\n")

        # maintain a dict from variable names to search paths
        self.variables = {}

    def generateVariableName(self, predicate):
        # Ensure uniqueness
        result = predicate.makeScriptVariableName()
        if result in self.variables:
            # This variable name is already in use; need to append a number:
            index = 1
            while result+str(index) in self.variables:
                index+=1
            return result+str(index)
        else:
            return result

    def printVariables(self):
        # debug hook
        print "variables:"
        for (varName, varAbsPath) in self.variables.iteritems():
            print "varName:%s -> absPath:%s"%(varName, varAbsPath)

    def generateAbsSearchPathMethodCall(self, absSearchPath):
        """
        Generates a method call that identifies the absolute search path,
        optimizing away prefixes where possible with variable names.
        """
        # We optimize away the longest common absolute path prefix, i.e. the
        # shortest relative path suffix:
        if self.debug:
            print "*******************"
            print "generateAbsSearchPathMethodCall for %s"%absSearchPath
            self.printVariables()

        shortestRelativePath = None
        for (varName, varAbsPath) in self.variables.iteritems():
            relPath = varAbsPath.getRelativePath(absSearchPath)
            if relPath:
                if shortestRelativePath:
                    if relPath.length() < shortestRelativePath[2].length():
                        shortestRelativePath = (varName, varAbsPath, relPath)
                else:
                    shortestRelativePath = (varName, varAbsPath, relPath)

        if self.debug:
            if shortestRelativePath:
                (varName, varAbsPath, relPath) = shortestRelativePath
                print "shortestRelativePath: (%s, %s, %s)"%(varName, varAbsPath, relPath)
            else:
                print "shortestRelativePath: None"
            print "*******************"

        if shortestRelativePath:
            (varName, varAbsPath, relPath) = shortestRelativePath
            return varName+relPath.makeScriptMethodCall()
        else:
            # Have to specify it as an absolute path:
            return "root"+absSearchPath.makeScriptMethodCall()

    def recordKey(self, node, key):
        """
        Record a keystroke

        NOTE: This function is under construction. It doesn't work.
        """
        if node == None: return
        searchPath = node.getAbsoluteSearchPath()
        result = self.generateAbsSearchPathMethodCall(searchPath)
        result +=".rawType('%s')" % key

    def recordClick(self, node):
        """
        Record a mouse click
        """
        if node == None: return
        searchPath = node.getAbsoluteSearchPath()

        if self.debug:
            print "----------------------------------"
            print "click on %s"%searchPath
            print "Full script would be: root%s"%searchPath.makeScriptMethodCall()

        # Generate variables for nodes likely to be referred to often (application, window)
        # FIXME: make this smarter?
        for i in [1,2,3]:
            if i<searchPath.length():

                prefixPath = searchPath.getPrefix(i)

                if self.debugVariables:
                    print "Considering: %s"%prefixPath

                if not prefixPath in self.variables.values():
                    if self.debugVariables:
                        print "It is not yet a variable"
                        self.printVariables()

                    predicate = prefixPath.getPredicate(i-1)
                    varName = predicate.makeScriptVariableName()
                    self.recordLine(varName+" = "+self.generateAbsSearchPathMethodCall(prefixPath))
                    self.variables[varName]=prefixPath
                else:
                    if self.debugVariables:
                        print "It is already a variable"

        result = self.generateAbsSearchPathMethodCall(searchPath)
        result +=".click()"

        if self.debug:
            print "----------------------------------"

        self.recordLine(result)

class ProceduralScriptWriter(ScriptWriter):
    """
    Concrete Writer subclass which writes out Python scripts in a procedural
    style
    """
    
    currentWidget = None
    currentDialog = None
    currentApplication = None

    def __init__(self, scriptTextView = None):
        ScriptWriter.__init__(self, scriptTextView)

        self.recordLine("#!/usr/bin/python\nfrom dogtail.procedural import *\n")
    
    def findAncestor(self, node, name = None, roleName = None, description = None):
        while node.parent:
            nameMatch = False
            roleNameMatch = False
            descMatch = False
            if name != None: nameMatch = node.parent.name == name
            else: nameMatch = True
            if roleName != None: roleNameMatch = node.parent.roleName == roleName
            else: roleNameMatch = True
            if description != None: 
                descMatch = node.parent.description == description
            else: descMatch = True
            match = nameMatch and roleNameMatch and descMatch
            if match: return node.parent
            node = node.parent
        return None

    def recordClick(self, node):
        if node == None: return False
        
        application = self.findAncestor(node, roleName = 'application')
        if application:
            needApp = True
            if self.currentApplication:
                if application == self.currentApplication: needApp = False
            if needApp:
                self.recordLine("focus.application('%s')" % application.name)
                self.currentApplication = application

        dialog = self.findAncestor(node, roleName = 'dialog')
        if dialog:
            needDialog = True
            if dialog == self.currentDialog: needDialog = False
            if needDialog:
                self.recordLine("focus.dialog('%s')" % dialog.name)
                self.currentDialog = dialog
        
        widget = node
        possibleActions = ['click', 'activate', 'open', 'menu']
        foundAnAction = False
        for action in possibleActions:
            if action in widget.actions.keys():
                foundAnAction = True
                self.recordLine("%s('%s', roleName='%s')" % (action, widget.name, widget.roleName))
                break
        if not foundAnAction: 
            if hasattr(widget, 'select'):
                self.recordLine("select('%s', roleName='%s')" % (widget.name, widget.roleName))
            else:
                self.recordLine("click('%s', roleName='%s', raw=True)" % (widget.name, widget.roleName))
        self.currentWidget = widget
        

    def recordKey(self, node):
        pass


class FakeNode(dogtail.tree.Node):
    """A "cached pseudo-copy" of a Node

    This class exists for cases where we know we're going to need information
    about a Node instance at a point in time where it's no longer safe to
    assume that the Accessible it wraps is still valid. It is designed to
    cache enough information to allow all of the necessary Node methods to
    execute properly and return something meaningful.

    As it is often necessary to know the Node instance's parent, it creates
    FakeNode instances of each and every one of its ancestors.
    """
    def __init__(self, node):
        if node == None: raise TypeError, node

        self.__node = node
        self.name = self.__node.name
        self.roleName = self.__node.roleName
        self.description = self.__node.description
        self.actions = self.__node.actions
        self.debugName = self.__node.debugName

        self.text = self.__node.text

        self.position = self.__node.position

        self.size = self.__node.size

        if node.parent: self.parent = FakeNode(self.__node.parent)
        else: self.parent = None

        if node.labellee: self.labellee = FakeNode(self.__node.labellee)
        else: self.labellee = None

    def __getattr__(self, name):
        raise AttributeError, name

    def __setattr__(self, name, value):
        self.__dict__[name] = value

    def __cmp__(self, otherNode):
        if not otherNode: return True

        nameMatch = False
        roleNameMatch = False
        descMatch = False
        nameMatch = otherNode.name == self.name
        roleNameMatch = otherNode.roleName == self.roleName
        descMatch = otherNode.description == self.description
        match = nameMatch and roleNameMatch and descMatch
        return not match


# Singleton EventRecorder
global recorder

class EventRecorder:
    """
    Event Recorder
    """
    def __init__(self, writerClass = ProceduralScriptWriter):
        self.writer = None
        self.writerClass = writerClass
        self.lastFocusedNode = None
        self.lastSelectedNode = None
        self.lastPressedNode = None
        self.lastReleasedNode = None
        self.absoluteNodePaths = True

    def __registerEvents(self):
        # Only specific events are recorded:
        listeners = []

        # Focus events:
        listeners.append(atspi.EventListener(marshalOnFocus, ["focus:"]))

        # State Changed events:
        listeners.append(atspi.EventListener(marshalOnSelect, ["object:state-changed:selected"]))

        # Mouse button events:
        listeners.append(atspi.EventListener(marshalOnMouseButton, ["mouse:button"]))

        # Window creation:
        #listeners.append(atspi.EventListener(marshalOnWindowCreate, ["window:create"]))

        return listeners

    def startRecording(self, unused = None, scriptTextView = None):
        self.writer = self.writerClass(scriptTextView)
        self.listeners = self.__registerEvents()
        atspi.event_main()

    def stopRecording(self, unused = None, scriptTextView = None):
        for listener in self.listeners:
            listener.deregister()
        atspi.event_quit()
        self.writer = None

    def onFocus(self, event):
        #logEvent(event)

        sourceNode = dogtail.tree.Node(event.source)
        sourceNode = FakeNode(sourceNode)
        #if sourceNode == self.lastPressedNode or \
        #        sourceNode == self.lastReleasedNode:
        #    sourceNode._FakeNode__node.blink()
        self.lastFocusedNode = sourceNode

    def onSelect(self, event):
        #logEvent(event)

        sourceNode = dogtail.tree.Node(event.source)
        sourceNode = FakeNode(sourceNode)
        self.lastSelectedNode = sourceNode

    def onMouseButton(self, event):
        #logEvent(event)

        isPress = isRelease = False
        if "mouse:button:1" not in event.type:
            return
        elif event.type == "mouse:button:1p":
            isPress = True
        elif event.type == "mouse:button:1r":
            isRelease = True

        # The source node is always "main" - which sucks. We have to detect
        # the real source ourselves.

        def detectByCoordinates(nodes, x, y):
            # From a list of nodes, find the smallest one that (x, y) is in
            def isCandidate(node, x, y):
                # If (x, y) is inside the node, return True
                if node and node.position:
                    #print "x,y: %s, %s" % (x, y)
                    #print "position: %s, size: %s" % (node.position, node.size)
                    if node.position[0] <= x <= (node.position[0] + node.size[0]) and \
                            node.position[1] <= y <= (node.position[1] + node.size[1]):
                        return True
            def getAllDescendants(node):
                result = []
                for child in node.children:
                    result.append(child)
                    result.extend(getAllDescendants(child))
                    #for grandChild in child.children:
                    #    result.append(grandChild)
                return result
            def smallestNode(nodes):
                # Return the node with the smallest area
                areas = {}
                for node in nodes:
                    area = node.size[0] * node.size[1]
                    if areas.get(area, None):
                        print "Two nodes are the same size?!"
                        print str(areas[area]) + "|" + str(node)
                    areas[area] = node
                if areas:
                    return areas[min(areas.keys())]

            detectedNode = None
            for node in nodes:
                if isCandidate(node, x, y):
                    detectedNode = node
                    # table children don't send focus signals, so we have to
                    # find the child itself.
                    if node.roleName == 'table':
                        detectedNode = None
                        if not hasattr(node, 'children'):
                            node = node._FakeNode__node
                        # getAllDescendants() is very expensive :(
                        possibleNodes = getAllDescendants(node)
                        probableNodes = [n for n in possibleNodes if \
                                isCandidate(n, x, y)]
                        detectedNode = smallestNode(probableNodes)
            return detectedNode

        x = event.detail1
        y = event.detail2
        if self.lastSelectedNode != self.lastFocusedNode:
            possibleNodes = (self.lastSelectedNode, self.lastFocusedNode)
        else:
            # If self.lastSelectedNode isn't meaningful, don't waste time on 
            # it with detectByCoordinates().
            possibleNodes = [self.lastFocusedNode]
        detectedNode = detectByCoordinates(possibleNodes, x, y)
        if detectedNode:
            detectedNode = FakeNode(detectedNode)
        if isPress: 
            self.lastPressedNode = detectedNode
        elif isRelease:
            self.lastReleasedNode = detectedNode
        
        if isRelease and detectedNode:
            self.writer.recordClick(detectedNode)

    def onWindowCreate(self, event):
        # logEvent(event)
        sourceNode = dogtail.tree.Node(event.source)
        # print "Window creation: %s"%str(sourceNode)

    def getLogStringForNode(self, node):
        if self.absoluteNodePaths:
            return node.getAbsoluteSearchPath()
        else:
            return node

# Under construction.  These ought to be methods, but am having Python assertion
# failures in refcounting when trying to hook them up using lambda expressions; grrr...
def marshalOnFocus(event):
    recorder.onFocus(event)

def marshalOnSelect(event):
    recorder.onSelect(event)

def marshalOnMouseButton(event):
    recorder.onMouseButton(event)

def marshalOnWindowCreate(event):
    recorder.onWindowCreate(event)

recorder = EventRecorder()
recorderGUI = RecorderGUI()
#recorder.writer.debug = True
#recorder.writer.debugVariables = True


# vim: sw=4 ts=4 sts=4 et ai
